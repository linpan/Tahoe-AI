<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>从提示工程到上下文工程：构建强大LLM应用</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .slide {
            opacity: 0; transition: opacity 0.7s ease-in-out;
            min-height: 100vh; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            padding: 2rem 1rem 4rem 1rem;
        }
        .slide.active { opacity: 1; }
        .slide .content-wrapper { width: 80%; max-width: 900px; }

        .text-content p, .text-content li {
            line-height: 1.8; margin-bottom: 1.25rem; font-size: 1.125rem;
        }
        .text-content h2 { margin-bottom: 1.5rem; font-size: 2.25rem; }
        .text-content h3 { margin-bottom: 1rem; font-size: 1.875rem; }
        .text-content ul { list-style-type: disc; list-style-position: outside; padding-left: 1.75rem; margin-bottom: 1rem; }
        .text-content code { background-color: #374151; color: #e5e7eb; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.9em;}
        .highlight { color: #f59e0b; /* amber-500 */ font-weight: 600; }
    </style>
</head>
<body class="bg-gray-950 text-gray-200 font-sans">

    <div id="presentation-container" class="relative w-full min-h-screen overflow-y-auto">

        <!-- Slide 1: Title Slide -->
        <div class="slide p-8 flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-amber-800 to-gray-900 text-center">
            <div class="w-full max-w-4xl">
                <h1 class="text-5xl md:text-6xl font-extrabold mb-6 text-amber-300 drop-shadow-lg">
                    超越“提示”：拥抱“上下文工程”
                </h1>
                <h2 class="text-3xl md:text-4xl font-semibold mb-8 text-amber-200">
                    构建工业级LLM应用的真正挑战
                </h2>
            </div>
        </div>

        <!-- Slide 2: Shifting Terminology -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h2 class="font-bold text-amber-400 text-center">为“上下文工程”正名 (+1)</h2>
                <p>相较于“提示工程”(prompt engineering)，我更倾向于使用“上下文工程”(context engineering)。</p>
                <p>人们通常将“提示”与日常使用中给予LLM的简短任务描述联系起来。</p>
            </div>
        </div>

        <!-- Slide 3: The Essence of Context Engineering -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h2 class="font-bold text-amber-400 text-center">上下文工程的精髓</h2>
                <p>然而，在每一个工业级LLM应用中，<span class="highlight">上下文工程</span>是一门精巧的艺术与科学——即为下一步操作，用恰到好处的信息填满上下文窗口。</p>
                <ul class="list-disc space-y-2">
                    <li><strong class="text-amber-300">科学性：</strong> 正确执行涉及任务描述与解释、少样本示例 (few shot examples)、RAG (检索增强生成)、相关的（可能是多模态的）数据、工具、状态与历史记录、信息压缩等。</li>
                    <li><strong class="text-amber-300">艺术性：</strong> 源于对LLM“心理”和人类心智的直觉引导。</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4: The Stakes of Context Engineering -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h3 class="font-semibold text-amber-300 text-center">上下文工程的利害关系</h3>
                <p>信息太少或形式不对，LLM就无法获得最佳性能所需的上下文。</p>
                <p>信息太多或太不相关，LLM的成本可能会上升，性能反而可能下降。</p>
                <p class="italic">做好这一点是高度不平凡的。</p>
            </div>
        </div>

        <!-- Slide 5: Beyond Context Engineering - LLM App Complexity (Part 1) -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h2 class="font-bold text-amber-400 text-center">LLM应用的复杂性：远不止上下文</h2>
                <p>在上下文工程本身之上，一个LLM应用还必须处理更多：</p>
                <ul class="list-disc space-y-3">
                    <li>将问题<span class="highlight">恰到好处地分解</span>为控制流 (control flows)。</li>
                    <li><span class="highlight">恰到好处地填充</span>上下文窗口。</li>
                    <li>将调用<span class="highlight">分派给类型和能力合适的</span>LLM。</li>
                </ul>
            </div>
        </div>

        <!-- Slide 6: Beyond Context Engineering - LLM App Complexity (Part 2) -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                 <h2 class="font-bold text-amber-400 text-center">LLM应用的复杂性 (续)</h2>
                <ul class="list-disc space-y-3">
                    <li>处理<span class="highlight">生成-验证 (generation-verification)</span> 的用户体验与用户界面 (UIUX) 流程。</li>
                    <li>还有更多——<span class="highlight">护栏 (guardrails)、安全性、评估 (evals)、并行处理、预取 (prefetching)</span> 等等。</li>
                </ul>
            </div>
        </div>

        <!-- Slide 7: Context Engineering as a Piece of the Puzzle -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h3 class="font-semibold text-amber-300 text-center">上下文工程：拼图的一小块</h3>
                <p>因此，上下文工程只是一个新兴的、厚重的、不平凡的软件层中的一小部分。这个软件层负责协调单个LLM调用（以及更多事务），从而构成完整的LLM应用。</p>
                <p class="text-2xl font-bold text-center mt-8">“ChatGPT包装器”的说法已经过时，而且<span class="highlight">大错特错</span>。</p>
            </div>
        </div>

        <!-- Slide 8: Reiterating Context Engineering (Due to Repetition in Original Text) -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h2 class="font-bold text-amber-400 text-center">再次强调：上下文工程的重要性</h2>
                <p>（原文此处重复了之前关于上下文工程的定义和重要性，我们再次强调其核心）</p>
                <p>人们通常将“提示”与日常使用中给予LLM的简短任务描述联系起来。然而，在每一个工业级LLM应用中，<span class="highlight">上下文工程</span>是为下一步操作，用恰到好处的信息（任务描述、少样本、RAG、数据、工具、状态、历史、压缩等）填满上下文窗口的精巧艺术与科学。</p>
                <p>信息过多、过少、形式错误或不相关，都会直接影响LLM的性能和成本。这绝非易事。</p>
            </div>
        </div>

        <!-- Slide 9: Reiterating LLM App Complexity (Due to Repetition) -->
        <div class="slide bg-gray-900 hidden">
            <div class="content-wrapper text-content">
                <h2 class="font-bold text-amber-400 text-center">再次强调：LLM应用的整体挑战</h2>
                <p>（原文此处重复了LLM应用除上下文工程外的其他挑战，我们再次概括）</p>
                <p>一个成熟的LLM应用，除了精妙的上下文工程，还需妥善处理问题分解、控制流、多模型调度、生成-验证流程，以及护栏、安全、评估、并行、预取等一系列复杂问题。</p>
                <p class="text-xl font-semibold text-center mt-6">上下文工程，虽至关重要，却也只是构建强大LLM应用所需复杂软件栈中的一环。</p>
            </div>
        </div>


        <!-- Slide 10: Conclusion -->
        <div class="slide p-8 flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-gray-900 to-amber-800 text-center">
            <div class="w-full max-w-3xl">
                <h2 class="text-4xl font-bold mb-8 text-amber-300">结论：重新审视LLM应用开发</h2>
                <p class="text-xl text-gray-200 leading-relaxed">
                    我们需要超越简单的“提示”概念，深入理解和实践“上下文工程”这门艺术与科学。
                </p>
                <p class="text-xl text-gray-200 leading-relaxed mt-4">
                    同时，要认识到构建真正有价值的LLM应用，涉及到一个远比“包装API”复杂得多的软件工程体系。
                </p>
                <p class="text-lg text-gray-300 mt-8 leading-relaxed">
                    这不仅是对技术的挑战，更是对我们构建智能系统思维方式的革新。
                </p>
            </div>
        </div>

        <!-- Navigation Buttons -->
        <div class="fixed bottom-6 left-1/2 -translate-x-1/2 flex space-x-4 z-20">
            <button id="prevBtn" class="px-6 py-3 bg-amber-600 hover:bg-amber-700 text-white font-semibold rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled aria-label="上一页">
                ← 上一页
            </button>
            <button id="nextBtn" class="px-6 py-3 bg-amber-600 hover:bg-amber-700 text-white font-semibold rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105" aria-label="下一页">
                下一页 →
            </button>
        </div>
        <div class="fixed bottom-1 left-1/2 -translate-x-1/2 text-xs text-gray-500 z-20">
            <span id="slideCounter"></span>
        </div>

    </div>

    <script>
        const slides = document.querySelectorAll('.slide');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const slideCounter = document.getElementById('slideCounter');
        let currentSlide = 0;

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.remove('active');
                if (i === index) {
                    slide.classList.remove('hidden');
                    setTimeout(() => slide.classList.add('active'), 10);
                } else {
                    if (!slide.classList.contains('active')) {
                         slide.classList.add('hidden');
                    }
                }
            });
            updateButtons();
            updateSlideCounter();
        }

        function updateButtons() {
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;
        }

        function updateSlideCounter() {
            slideCounter.textContent = `第 ${currentSlide + 1} 页 / 共 ${slides.length} 页`;
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                slides[currentSlide].classList.remove('active');
                setTimeout(() => {
                    slides[currentSlide].classList.add('hidden');
                    currentSlide++;
                    showSlide(currentSlide);
                }, 350);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                slides[currentSlide].classList.remove('active');
                setTimeout(() => {
                    slides[currentSlide].classList.add('hidden');
                    currentSlide--;
                    showSlide(currentSlide);
                }, 350);
            }
        }

        prevBtn.addEventListener('click', prevSlide);
        nextBtn.addEventListener('click', nextSlide);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevSlide();
            }
        });

        showSlide(currentSlide);
    </script>
</body>
</html>